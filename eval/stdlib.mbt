///|
fn stdlib_source() -> String {
  let lines : Array[String] = [
    "(define (fold-left f acc lst)", "  (let loop ((acc acc) (lst lst))", "    (if (null? lst) acc",
    "        (loop (f acc (car lst)) (cdr lst)))))", "(define (fold-right f acc lst)",
    "  (if (null? lst) acc", "      (f (car lst) (fold-right f acc (cdr lst)))))",
    "(define (filter pred lst)", "  (cond ((null? lst) '())", "        ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))",
    "        (else (filter pred (cdr lst)))))", "(define (remove pred lst)", "  (filter (lambda (x) (not (pred x))) lst))",
    "(define (find pred lst)", "  (cond ((null? lst) #f)", "        ((pred (car lst)) (car lst))",
    "        (else (find pred (cdr lst)))))", "(define (any pred lst)", "  (cond ((null? lst) #f)",
    "        ((pred (car lst)) #t)", "        (else (any pred (cdr lst)))))", "(define (every pred lst)",
    "  (cond ((null? lst) #t)", "        ((pred (car lst)) (every pred (cdr lst)))",
    "        (else #f)))", "(define (take lst n)", "  (if (<= n 0) '()", "      (cons (car lst) (take (cdr lst) (- n 1)))))",
    "(define (drop lst n)", "  (if (<= n 0) lst", "      (drop (cdr lst) (- n 1))))",
    "(define (take-while pred lst)", "  (cond ((null? lst) '())", "        ((pred (car lst)) (cons (car lst) (take-while pred (cdr lst))))",
    "        (else '())))", "(define (drop-while pred lst)", "  (cond ((null? lst) '())",
    "        ((pred (car lst)) (drop-while pred (cdr lst)))", "        (else lst)))",
    "(define (append-map f lst)", "  (if (null? lst) '()", "      (append (f (car lst)) (append-map f (cdr lst)))))",
    "(define (count pred lst)", "  (fold-left (lambda (acc x) (if (pred x) (+ acc 1) acc)) 0 lst))",
    "(define (list-index pred lst)", "  (let loop ((lst lst) (idx 0))", "    (cond ((null? lst) #f)",
    "          ((pred (car lst)) idx)", "          (else (loop (cdr lst) (+ idx 1))))))",
    "(define (partition pred lst)", "  (let loop ((lst lst) (yes '()) (no '()))",
    "    (if (null? lst)", "        (list (reverse yes) (reverse no))", "        (if (pred (car lst))",
    "            (loop (cdr lst) (cons (car lst) yes) no)", "            (loop (cdr lst) yes (cons (car lst) no))))))",
    "(define (zip xs ys)", "  (if (or (null? xs) (null? ys))", "      '()", "      (cons (list (car xs) (car ys)) (zip (cdr xs) (cdr ys)))))",
    "(define (unzip pairs)", "  (let loop ((pairs pairs) (xs '()) (ys '()))", "    (if (null? pairs)",
    "        (list (reverse xs) (reverse ys))", "        (let ((p (car pairs)))",
    "          (loop (cdr pairs) (cons (car p) xs) (cons (cadr p) ys))))))", "(define (last lst)",
    "  (if (null? (cdr lst)) (car lst) (last (cdr lst))))", "(define (string-join strs sep)",
    "  (if (null? strs) \"\"", "      (let loop ((rest (cdr strs)) (acc (car strs)))",
    "        (if (null? rest) acc", "            (loop (cdr rest) (string-append acc sep (car rest)))))))",
    "(define (list-tabulate n f)", "  (let loop ((idx 0) (acc '()))", "    (if (>= idx n)",
    "        (reverse acc)", "        (loop (+ idx 1) (cons (f idx) acc)))))", "(define (div x y)",
    "  (let* ((q (quotient x y))", "         (r (remainder x y)))", "    (if (zero? r) q",
    "        (if (and (> r 0) (< y 0)) (- q 1)", "            (if (and (< r 0) (> y 0)) (- q 1) q)))))",
    "(define (mod x y)", "  (let ((r (remainder x y)))", "    (if (zero? r) r", "        (if (and (> r 0) (< y 0)) (+ r y)",
    "            (if (and (< r 0) (> y 0)) (+ r y) r)))))", "(define (div-and-mod x y)",
    "  (let* ((q (div x y))", "         (r (- x (* y q))))", "    (values q r)))",
    "(define (div0 x y) (quotient x y))", "(define (mod0 x y) (remainder x y))",
    "(define (div0-and-mod0 x y)", "  (values (quotient x y) (remainder x y)))",
    "(define-condition-type &message &condition", "  make-message-condition message-condition?",
    "  (message condition-message))", "(define-condition-type &warning &condition",
    "  make-warning warning?)", "(define-condition-type &serious &condition", "  make-serious-condition serious-condition?)",
    "(define-condition-type &error &serious", "  make-error error?)", "(define-condition-type &violation &serious",
    "  make-violation violation?)", "(define-condition-type &assertion &violation",
    "  make-assertion-violation assertion-violation?)", "(define-condition-type &irritants &condition",
    "  make-irritants-condition irritants-condition?", "  (irritants condition-irritants))",
    "(define-condition-type &who &condition", "  make-who-condition who-condition?",
    "  (who condition-who))", "(define-condition-type &non-continuable &violation",
    "  make-non-continuable-violation non-continuable-violation?)", "(define-condition-type &implementation-restriction &violation",
    "  make-implementation-restriction-violation", "  implementation-restriction-violation?)",
    "(define-condition-type &lexical &violation", "  make-lexical-violation lexical-violation?)",
    "(define-condition-type &syntax &violation", "  make-syntax-violation syntax-violation?",
    "  (form syntax-violation-form)", "  (subform syntax-violation-subform))", "(define-condition-type &undefined &violation",
    "  make-undefined-violation undefined-violation?)", "(define-condition-type &no-infinities &implementation-restriction",
    "  make-no-infinities-violation no-infinities-violation?)", "(define-condition-type &no-nans &implementation-restriction",
    "  make-no-nans-violation no-nans-violation?)", "(library (rnrs control (6))",
    "  (export case-lambda do when unless)", "  (import)", "  (define-syntax when",
    "    (syntax-rules ()", "      ((_ test body ...) (if test (begin body ...) (begin)))))",
    "  (define-syntax unless", "    (syntax-rules ()", "      ((_ test body ...) (if (not test) (begin body ...) (begin)))))",
    ")", "(library (rnrs syntax-case (6))", "  (export syntax-case with-syntax syntax quasisyntax unsyntax unsyntax-splicing ... _",
    "          make-variable-transformer generate-temporaries", "          syntax->datum datum->syntax free-identifier=? bound-identifier=?",
    "          identifier? syntax? syntax-violation)", "  (import)", ")", "(library (rnrs arithmetic fixnums (6))",
    "  (export fixnum? fixnum-width least-fixnum greatest-fixnum", "          fx=? fx<? fx>? fx<=? fx>=?",
    "          fxzero? fxpositive? fxnegative? fxodd? fxeven?", "          fxmax fxmin",
    "          fx+ fx- fx* fxdiv fxmod fxdiv0 fxmod0 fx+/carry fx-/carry fx*/carry",
    "          fxnot fxand fxior fxxor fxif", "          fxbit-count fxlength fxfirst-bit-set fxbit-set? fxcopy-bit fxbit-field",
    "          fxcopy-bit-field fxrotate-bit-field fxreverse-bit-field", "          fxarithmetic-shift fxarithmetic-shift-left fxarithmetic-shift-right)",
    "  (import)", ")", "(library (rnrs arithmetic bitwise (6))", "  (export bitwise-and bitwise-ior bitwise-xor bitwise-not bitwise-if",
    "          arithmetic-shift bitwise-bit-count bitwise-length bitwise-first-bit-set",
    "          bitwise-bit-set? bitwise-copy-bit bitwise-bit-field bitwise-copy-bit-field",
    "          bitwise-rotate-bit-field bitwise-reverse-bit-field)", "  (import)",
    ")", "(library (rnrs mutable-pairs (6))", "  (export set-car! set-cdr!)", "  (import)",
    ")", "(library (rnrs mutable-strings (6))", "  (export string-set! string-fill! string-copy!)",
    "  (import)", ")", "(library (rnrs bytevectors (6))", "  (export bytevector make-bytevector bytevector? bytevector-length",
    "          bytevector=? bytevector-u8-ref bytevector-u8-set! bytevector-s8-ref",
    "          bytevector-s8-set! bytevector-copy", "          bytevector-copy! bytevector-append bytevector-fill!",
    "          bytevector->u8-list u8-list->bytevector", "          string->utf8 utf8->string",
    "          endianness native-endianness", "          bytevector-uint-ref bytevector-sint-ref",
    "          bytevector-uint-set! bytevector-sint-set!", "          bytevector-u16-ref bytevector-u16-native-ref",
    "          bytevector-u16-set! bytevector-u16-native-set!", "          bytevector-s16-ref bytevector-s16-native-ref",
    "          bytevector-s16-set! bytevector-s16-native-set!", "          bytevector-u32-ref bytevector-u32-native-ref",
    "          bytevector-u32-set! bytevector-u32-native-set!", "          bytevector-s32-ref bytevector-s32-native-ref",
    "          bytevector-s32-set! bytevector-s32-native-set!", "          bytevector-u64-ref bytevector-u64-native-ref",
    "          bytevector-u64-set! bytevector-u64-native-set!", "          bytevector-s64-ref bytevector-s64-native-ref",
    "          bytevector-s64-set! bytevector-s64-native-set!)", "  (import)", "  (define-syntax endianness",
    "    (syntax-rules (big little)", "      ((_ big) 'big)", "      ((_ little) 'little)))",
    "  (define (bytevector-s8-ref bv k)", "    (let ((v (bytevector-u8-ref bv k)))",
    "      (if (> v 127) (- v 256) v)))", "  (define (bytevector-s8-set! bv k val)",
    "    (if (or (< val -128) (> val 127))", "        (assertion-violation 'bytevector-s8-set! \"value out of range\" val)",
    "        (bytevector-u8-set! bv k (if (< val 0) (+ val 256) val))))", "  (define (bytevector-u16-ref bv k end)",
    "    (bytevector-uint-ref bv k end 2))", "  (define (bytevector-u16-native-ref bv k)",
    "    (bytevector-uint-ref bv k (native-endianness) 2))", "  (define (bytevector-u16-set! bv k end val)",
    "    (bytevector-uint-set! bv k end 2 val))", "  (define (bytevector-u16-native-set! bv k val)",
    "    (bytevector-uint-set! bv k (native-endianness) 2 val))", "  (define (bytevector-s16-ref bv k end)",
    "    (bytevector-sint-ref bv k end 2))", "  (define (bytevector-s16-native-ref bv k)",
    "    (bytevector-sint-ref bv k (native-endianness) 2))", "  (define (bytevector-s16-set! bv k end val)",
    "    (bytevector-sint-set! bv k end 2 val))", "  (define (bytevector-s16-native-set! bv k val)",
    "    (bytevector-sint-set! bv k (native-endianness) 2 val))", "  (define (bytevector-u32-ref bv k end)",
    "    (bytevector-uint-ref bv k end 4))", "  (define (bytevector-u32-native-ref bv k)",
    "    (bytevector-uint-ref bv k (native-endianness) 4))", "  (define (bytevector-u32-set! bv k end val)",
    "    (bytevector-uint-set! bv k end 4 val))", "  (define (bytevector-u32-native-set! bv k val)",
    "    (bytevector-uint-set! bv k (native-endianness) 4 val))", "  (define (bytevector-s32-ref bv k end)",
    "    (bytevector-sint-ref bv k end 4))", "  (define (bytevector-s32-native-ref bv k)",
    "    (bytevector-sint-ref bv k (native-endianness) 4))", "  (define (bytevector-s32-set! bv k end val)",
    "    (bytevector-sint-set! bv k end 4 val))", "  (define (bytevector-s32-native-set! bv k val)",
    "    (bytevector-sint-set! bv k (native-endianness) 4 val))", "  (define (bytevector-u64-ref bv k end)",
    "    (bytevector-uint-ref bv k end 8))", "  (define (bytevector-u64-native-ref bv k)",
    "    (bytevector-uint-ref bv k (native-endianness) 8))", "  (define (bytevector-u64-set! bv k end val)",
    "    (bytevector-uint-set! bv k end 8 val))", "  (define (bytevector-u64-native-set! bv k val)",
    "    (bytevector-uint-set! bv k (native-endianness) 8 val))", "  (define (bytevector-s64-ref bv k end)",
    "    (bytevector-sint-ref bv k end 8))", "  (define (bytevector-s64-native-ref bv k)",
    "    (bytevector-sint-ref bv k (native-endianness) 8))", "  (define (bytevector-s64-set! bv k end val)",
    "    (bytevector-sint-set! bv k end 8 val))", "  (define (bytevector-s64-native-set! bv k val)",
    "    (bytevector-sint-set! bv k (native-endianness) 8 val))", ")", "(library (rnrs hashtables (6))",
    "  (export make-eq-hashtable make-eqv-hashtable make-hashtable hashtable?", "          hashtable-size hashtable-ref hashtable-set! hashtable-delete!",
    "          hashtable-contains? hashtable-update! hashtable-copy hashtable-clear!",
    "          hashtable-keys hashtable-entries hashtable-equivalence-function",
    "          hashtable-hash-function hashtable-mutable?", "          equal-hash string-hash string-ci-hash symbol-hash)",
    "  (import)", ")", "(library (rnrs enums (6))", "  (export define-enumeration make-enumeration enum-set-universe enum-set-indexer",
    "          enum-set-constructor enum-set? enum-set-member? enum-set-subset?",
    "          enum-set=? enum-set-union enum-set-intersection enum-set-difference",
    "          enum-set-complement enum-set-projection enum-set->list)", "  (import)",
    ")", "(library (rnrs unicode (6))", "  (export char-alphabetic? char-numeric? char-whitespace?",
    "          char-upper-case? char-lower-case? char-upcase char-downcase", "          char-foldcase char-general-category",
    "          string-upcase string-downcase string-foldcase", "          string-normalize-nfc string-normalize-nfd",
    "          string-normalize-nfkc string-normalize-nfkd)", "  (import)", ")",
    "(library (rnrs exceptions (6))", "  (export guard with-exception-handler raise raise-continuable error",
    "          assertion-violation implementation-restriction-violation", "          undefined-violation syntax-violation)",
    "  (import)", ")", "(library (rnrs records syntactic (6))", "  (export define-record-type fields immutable mutable nongenerative opaque",
    "          parent parent-rtd protocol record-constructor-descriptor", "          record-type-descriptor sealed)",
    "  (import)", ")", "(library (rnrs records procedural (6))", "  (export make-record-type-descriptor record-type-descriptor?",
    "          record-type-name record-type-parent record-type-uid", "          record-type-generative? record-type-sealed? record-type-opaque?",
    "          record-type-field-names record-type-field-mutable?", "          make-record-constructor-descriptor record-constructor-descriptor?",
    "          record-constructor record-predicate record-accessor record-mutator)",
    "  (import)", ")", "(library (rnrs records inspection (6))", "  (export record? record-rtd record-type-name record-type-parent record-type-uid",
    "          record-type-generative? record-type-sealed? record-type-opaque?",
    "          record-type-field-names record-type-field-mutable?)", "  (import)",
    ")", "(library (rnrs lists (6))", "  (export find find-tail for-all exists filter partition fold-left fold-right",
    "          remp remove remq remv memp memq memv assp assq assv assoc", "          member cons*)",
    "  (import)", "  (define (fold-left f acc lst)", "    (let loop ((acc acc) (lst lst))",
    "      (if (null? lst) acc", "          (loop (f acc (car lst)) (cdr lst)))))",
    "  (define (fold-right f acc lst)", "    (if (null? lst) acc", "        (f (car lst) (fold-right f acc (cdr lst)))))",
    "  (define (filter pred lst)", "    (cond ((null? lst) '())", "          ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))",
    "          (else (filter pred (cdr lst)))))", "  (define (remove pred lst)",
    "    (filter (lambda (x) (not (pred x))) lst))", "  (define (remp pred lst)",
    "    (remove pred lst))", "  (define (remq obj lst)", "    (remp (lambda (x) (eq? x obj)) lst))",
    "  (define (remv obj lst)", "    (remp (lambda (x) (eqv? x obj)) lst))", "  (define (find pred lst)",
    "    (cond ((null? lst) #f)", "          ((pred (car lst)) (car lst))", "          (else (find pred (cdr lst)))))",
    "  (define (find-tail pred lst)", "    (cond ((null? lst) #f)", "          ((pred (car lst)) lst)",
    "          (else (find-tail pred (cdr lst)))))", "  (define (partition pred lst)",
    "    (let loop ((lst lst) (yes '()) (no '()))", "      (if (null? lst)", "          (list (reverse yes) (reverse no))",
    "          (if (pred (car lst))", "              (loop (cdr lst) (cons (car lst) yes) no)",
    "              (loop (cdr lst) yes (cons (car lst) no))))))", "  (define (any-null? lists)",
    "    (cond ((null? lists) #f)", "          ((null? (car lists)) #t)", "          (else (any-null? (cdr lists)))))",
    "  (define (for-all pred . lists)", "    (if (null? lists) #t", "        (let loop ((lists lists))",
    "          (if (any-null? lists)", "              #t", "              (and (apply pred (map car lists))",
    "                   (loop (map cdr lists)))))))", "  (define (exists pred . lists)",
    "    (if (null? lists) #f", "        (let loop ((lists lists))", "          (if (any-null? lists)",
    "              #f", "              (let ((value (apply pred (map car lists))))",
    "                (if value value (loop (map cdr lists))))))))", "  (define (memp pred lst)",
    "    (cond ((null? lst) #f)", "          ((pred (car lst)) lst)", "          (else (memp pred (cdr lst)))))",
    "  (define (assp pred alist)", "    (cond ((null? alist) #f)", "          ((pred (caar alist)) (car alist))",
    "          (else (assp pred (cdr alist)))))", "  (define (cons* . args)", "    (cond ((null? args) '())",
    "          ((null? (cdr args)) (car args))", "          (else (cons (car args) (apply cons* (cdr args))))))",
    ")", "(library (rnrs sorting (6))", "  (export list-sort vector-sort vector-sort!)",
    "  (import)", "  (define (list-sort less? lst)", "    (define (merge a b)", "      (cond ((null? a) b)",
    "            ((null? b) a)", "            ((less? (car b) (car a))", "             (cons (car b) (merge a (cdr b))))",
    "            (else", "             (cons (car a) (merge (cdr a) b)))))", "    (define (split lst)",
    "      (let loop ((slow lst) (fast lst) (acc '()))", "        (if (or (null? fast) (null? (cdr fast)))",
    "            (list (reverse acc) slow)", "            (loop (cdr slow) (cddr fast) (cons (car slow) acc)))))",
    "    (define (sort lst)", "      (if (or (null? lst) (null? (cdr lst)))", "          lst",
    "          (let* ((parts (split lst))", "                 (left (car parts))",
    "                 (right (cadr parts)))", "            (merge (sort left) (sort right)))))",
    "    (sort lst))", "  (define (vector-sort less? vec)", "    (list->vector (list-sort less? (vector->list vec))))",
    "  (define (vector-sort! less? vec)", "    (let* ((sorted (vector-sort less? vec))",
    "           (len (vector-length sorted)))", "      (vector-copy! vec 0 sorted 0 len)",
    "      vec))", ")",
  ]
  lines.join("\n")
}

///|
fn load_stdlib(env : Env) -> Unit raise {
  let forms = parse_program(stdlib_source())
  for form in forms {
    let _ = eval_expr(form, env)

  }
}
